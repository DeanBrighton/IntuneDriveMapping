<#
	.DESCRIPTION
		This script performs network drive mappings with PowerShell and is auto generated by the intune-drive-mapping-generator (https://intunedrivemapping.azurewebsites.net).
		When executed under SYSTEM authority a scheduled task is created to ensure recurring script execution on each user logon.

	.NOTES
		Author: Nicola Suter, nicolonsky tech: https://tech.nicolonsky.ch
#>

[CmdletBinding()]
Param()

###########################################################################################
# Start transcript for logging															  #
###########################################################################################

Start-Transcript -Path $(Join-Path $env:temp "DriveMapping.log")

###########################################################################################
# Input values from generator															  #
###########################################################################################

$driveMappingJson = '[{"Path":"\\\\ds.nicolonsky.ch\\root\\public","DriveLetter":"P","Label":"Public","Id":0,"GroupFilter":null},{"Path":"\\\\ds.nicolonsky.ch\\root","DriveLetter":"F","Label":"DFS","Id":1,"GroupFilter":null}]'

$driveMappingConfig = $driveMappingJson | ConvertFrom-Json -ErrorAction Stop

# Override with your Active Directory Domain Name e.g. 'ds.nicolonsky.ch' if you haven't configured the domain name as DHCP option
$overrideUserDnsDomain = ""

###########################################################################################
# Helper function to determine a users group membership									  #
###########################################################################################

# Kudos for Tobias RenstrÃ¶m who showed me this!
function Get-ADGroupMembership {
	param(
		[parameter(Mandatory = $true)]
		[string]$UserPrincipalName
	)
	
	process {

		try {

            if ([string]::IsNullOrEmpty($env:USERDNSDOMAIN) -and [string]::IsNullOrEmpty($overrideUserDnsDomain)) {
			    Write-Error "Security group filtering won't work because `$env:USERDNSDOMAIN is not available!"
                Write-Warning "You can override your AD Domain in the `$overrideUserDnsDomain variable"
		    }else{

			    $Searcher = New-Object -TypeName System.DirectoryServices.DirectorySearcher
			    $Searcher.Filter = "(&(userprincipalname=$UserPrincipalName))"
			    $Searcher.SearchRoot = "LDAP://$env:USERDNSDOMAIN"
			    $DistinguishedName = $Searcher.FindOne().Properties.distinguishedname
			    $Searcher.Filter = "(member:1.2.840.113556.1.4.1941:=$DistinguishedName)"
			
			    [void]$Searcher.PropertiesToLoad.Add("name")
			
			    $List = [System.Collections.Generic.List[String]]@()

			    $Results = $Searcher.FindAll()
			
			    foreach ($Result in $Results) {
				    $ResultItem = $Result.Properties
				    [void]$List.add($ResultItem.name)
			    }
		
			    $List
            }

		}
		catch {
			#Nothing we can do
			Write-Warning $_.Exception.Message
		}
	}
}

#check if running as system
function Test-RunningAsSystem {
	[CmdletBinding()]
	param()
	process {
		return [bool]($(whoami -user) -match "S-1-5-18")
	}
}

###########################################################################################
# Get current group membership for the group filter capabilities						  #
###########################################################################################

Write-Output "Running as SYSTEM: $(Test-RunningAsSystem)"

if ($driveMappingConfig.GroupFilter) {
	try {
		#check if running as user and not system
		if (-not (Test-RunningAsSystem)) {

			$groupMemberships = Get-ADGroupMembership -UserPrincipalName $(whoami -upn)
		}
	}
	catch {
		#nothing we can do
	}	 
}
###########################################################################################
# Mapping network drives																  #
###########################################################################################
#Get PowerShell drives and rename properties

if (-not (Test-RunningAsSystem)) {

	try {

		$psDrives = Get-PSDrive | Select-Object @{N = "DriveLetter"; E = { $_.Name } }, @{N = "Path"; E = { $_.DisplayRoot } }
	
	}
	catch {
	
		Write-Warning $_.Exception.Message
	}
	
	#iterate through all network drive configuration entries

	foreach ($drive in $driveMappingConfig){

		try {
	
			#check if variable in unc path exists, e.g. for $env:USERNAME
			if ($drive.Path -match '\$env:') {
	
				$drive.Path = $ExecutionContext.InvokeCommand.ExpandString($drive.Path)
				
			}
	
			#if label is null we need to set it to empty in order to avoid error
			if ($null -eq $drive.Label) {
				$drive.Label = ""
			}
			
			#check if the drive is already connected with an identical configuration
			if ( -not ($psDrives.Path -contains $drive.Path -and $psDrives.DriveLetter -contains $drive.DriveLetter)) {
	
				$mapDrive = $false

				#check if drive exists - but with wrong config - to delete it
				if ($psDrives.Path -ne $drive.Path -or $psDrives.DriveLetter -ne $drive.DriveLetter) {
	
					Get-PSDrive | Where-Object { $_.DisplayRoot -eq $drive.Path -or $_.Name -eq $drive.DriveLetter } | Remove-PSDrive -EA Stop
				}
	
				## check item level targeting for group membership
				if ($null -ne $drive.GroupFilter -and $groupMemberships -contains $drive.GroupFilter) {
					
					$mapDrive = $true
				}
				elseif ($null -eq $drive.GroupFilter) {
	
					$mapDrive = $true
				}

				if ($mapDrive){
					Write-Output "Mapping network drive $($drive.Path)"
					$null = New-PSDrive -PSProvider FileSystem -Name $drive.DriveLetter -Root $drive.Path -Description $drive.Label -Persist -Scope global -EA Stop
					(New-Object -ComObject Shell.Application).NameSpace("$($drive.DriveLetter):").Self.Name = $drive.Label
				}
			}
			else {
					
				Write-Output "Drive '$($drive.DriveLetter):\' '$($drive.Path)' already exists with correct Drive Letter and Path"
			}
		}
		catch {
			$available = Test-Path $($drive.Path)
			if (-not $available){
				Write-Error "Unable to access path '$($drive.Path)' verify permissions and authentication!"
			}else{
				Write-Error $_.Exception.Message
			}
		}
	}

	
	# Fix to ensure drives are mapped as persistent!
	$null = Get-ChildItem -Path HKCU:\Network -ErrorAction SilentlyContinue | ForEach-Object { New-ItemProperty -Name ConnectionType -Value 1 -Path $_.PSPath -Force -ErrorAction SilentlyContinue }
}

###########################################################################################
# End & finish transcript
###########################################################################################

Stop-transcript

###########################################################################################
# Done
###########################################################################################

#!SCHTASKCOMESHERE!#

###########################################################################################
# If this script is running under system (IME) scheduled task is created  (recurring)
###########################################################################################

if (Test-RunningAsSystem) {

	Start-Transcript -Path $(Join-Path -Path $env:temp -ChildPath "IntuneDriveMappingScheduledTask.log")
	Write-Output "Running as System --> creating scheduled task which will run on user logon"

	###########################################################################################
	# Get the current script path and content and save it to the client
	###########################################################################################

	$currentScript = Get-Content -Path $($PSCommandPath)
	
	$schtaskScript = $currentScript[(0) .. ($currentScript.IndexOf("#!SCHTASKCOMESHERE!#") - 1)]

	$scriptSavePath = $(Join-Path -Path $env:ProgramData -ChildPath "intune-drive-mapping-generator")

	if (-not (Test-Path $scriptSavePath)) {

		New-Item -ItemType Directory -Path $scriptSavePath -Force
	}

	$scriptSavePathName = "DriveMappping.ps1"

	$scriptPath = $(Join-Path -Path $scriptSavePath -ChildPath $scriptSavePathName)

	$schtaskScript | Out-File -FilePath $scriptPath -Force

	###########################################################################################
	# Create dummy vbscript to hide PowerShell Window popping up at logon
	###########################################################################################

	$vbsDummyScript = "
	Dim shell,fso,file

	Set shell=CreateObject(`"WScript.Shell`")
	Set fso=CreateObject(`"Scripting.FileSystemObject`")

	strPath=WScript.Arguments.Item(0)

	If fso.FileExists(strPath) Then
		set file=fso.GetFile(strPath)
		strCMD=`"powershell -nologo -executionpolicy ByPass -command `" & Chr(34) & `"&{`" &_ 
		file.ShortPath & `"}`" & Chr(34) 
		shell.Run strCMD,0
	End If
	"

	$scriptSavePathName = "IntuneDriveMapping-VBSHelper.vbs"

	$dummyScriptPath = $(Join-Path -Path $scriptSavePath -ChildPath $scriptSavePathName)
	
	$vbsDummyScript | Out-File -FilePath $dummyScriptPath -Force

	$wscriptPath = Join-Path $env:SystemRoot -ChildPath "System32\wscript.exe"

	###########################################################################################
	# Register a scheduled task to run for all users and execute the script on logon
	###########################################################################################

	$schtaskName = "IntuneDriveMapping"
	$schtaskDescription = "Map network drives from intune-drive-mapping-generator."

	$trigger = New-ScheduledTaskTrigger -AtLogOn
	#Execute task in users context
	$principal = New-ScheduledTaskPrincipal -GroupId "S-1-5-32-545" -Id "Author"
	#call the vbscript helper and pass the PosH script as argument
	$action = New-ScheduledTaskAction -Execute $wscriptPath -Argument "`"$dummyScriptPath`" `"$scriptPath`""
	$settings = New-ScheduledTaskSettingsSet -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries
	
	$null = Register-ScheduledTask -TaskName $schtaskName -Trigger $trigger -Action $action  -Principal $principal -Settings $settings -Description $schtaskDescription -Force

	Start-ScheduledTask -TaskName $schtaskName

	Stop-Transcript
}

###########################################################################################
# Done
###########################################################################################
